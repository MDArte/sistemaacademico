// license-header java merge-point
// Generated by: ControleAcessoImpl.vsl in andromda-ejb-cartridge.
//

package br.mdarte.exemplo.academico.accessControl;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

import br.mdarte.exemplo.academico.util.Constantes;
import accessControl.exception.ControleAcessoException;
import br.gov.mdarte.controleacesso.cd.Acao;
import br.gov.mdarte.controleacesso.cd.AcaoDAOImpl;
import br.gov.mdarte.controleacesso.cd.Perfil;
import br.gov.mdarte.controleacesso.cd.PerfilDAOImpl;
import br.gov.mdarte.controleacesso.cd.UsuarioDAOImpl;
import br.gov.mdarte.controleacesso.cd.UsuarioImpl;


public  class ControleAcessoImpl extends accessControl.ControleAcesso {
	public static final int PROXIMA_TROCA_SENHA_DIAS = 30;
	/**
	 * Verifica se o operador necessita trocar senha obrigatoria
	 */
	@Override
	public boolean precisaTrocarSenha(accessControl.Operador operador) throws ControleAcessoException{
		return false;
	}
	
	/**
	 * Recupera o operador de acordo com o login
	 */
	@Override
	public accessControl.Operador getOperador(String usuario) throws ControleAcessoException{
		
		UsuarioDAOImpl usuarioDAO = new UsuarioDAOImpl();
		
		try {
			return (accessControl.Operador) usuarioDAO.recuperarUsuario(usuario);
		} catch (br.gov.mdarte.controleacesso.cd.DAOException exception) {
			throw new ControleAcessoException(exception);
		} catch (Exception exception) {
			throw new ControleAcessoException(exception);
		}
	}

	private HashMap<String, Collection<accessControl.Perfil>> addServices(HashMap<String,Collection<accessControl.Perfil>> hmServicos, Acao acao, Collection<accessControl.Perfil> perfis)
	{
		if(hmServicos.get(acao.getCodigo()) != null) {
			hmServicos.get(acao.getCodigo()).addAll(perfis);
		} else {
			hmServicos.put(acao.getCodigo(), perfis);
		}
		
		for(Acao acaoAgrupada : (Collection<Acao>) acao.getEAgrupadoPor()) {
			hmServicos = addServices(hmServicos, acaoAgrupada, perfis);
		}
		
		return hmServicos;
	}

	/**
	 * lista os servicos em um map onde a chave eh o nome do servico e o valor a colecao de perfis que possui acesso ao servico
	 */
	@Override
	public java.util.HashMap<String, java.util.Collection<accessControl.Perfil>> listaServicos() throws ControleAcessoException {
		
		HashMap<String, Collection<accessControl.Perfil>> hmServicos = new HashMap<String, Collection<accessControl.Perfil>>();
		
		AcaoDAOImpl acaoDAO = new AcaoDAOImpl();
		PerfilDAOImpl perfilDAO = new PerfilDAOImpl();

		ArrayList<Long> superPerfils = new ArrayList<Long>();
		List acaoList = new ArrayList();
		
		try {
			// recupera os perfils supers do sistema
			superPerfils = (ArrayList<Long>) perfilDAO.recuperarSuperPerfil(Constantes.SISTEMA, null);
			
			// recupera todos os serviços
			acaoList = (List) acaoDAO.recuperarAcoes(null);
		} catch(br.gov.mdarte.controleacesso.cd.DAOException exception) {
			throw new ControleAcessoException(exception);
		}
		
		for(Acao acao : (Collection<Acao>) acaoList) {
			Collection<Perfil> perfilAcaoList = acao.getPerfils();
			Collection<accessControl.Perfil> perfilList = new HashSet<accessControl.Perfil>();

			// adiciona SU para todos os servicos
			if (superPerfils != null && !superPerfils.isEmpty()) {
				for (Long idPerfil : superPerfils) {
					perfilList.add(new accessControl.Perfil(idPerfil.toString()));
				}
			}

			for(Perfil perfilCA : perfilAcaoList) {
			
				// Adiciona no mapa os perfis filhos, se houver. Implementação do agrupamento de perfis.
				Collection<Perfil> perfisDescendentes = recuperarPerfisDescendentes(perfilCA);
				for(Perfil perfilFilhoAtual : perfisDescendentes) {
					accessControl.Perfil perfilFilho = new accessControl.Perfil(perfilFilhoAtual.getId().toString());
					perfilList.add(perfilFilho);
				}
				
				accessControl.Perfil perfil = new accessControl.Perfil(perfilCA.getId().toString());
				perfilList.add(perfil);
			}
			
			if (!perfilList.isEmpty())
				hmServicos = addServices(hmServicos, acao, perfilList);
		}

		return hmServicos;
	}
	
	private Collection<Perfil> recuperarPerfisDescendentes(Perfil perfilUsuario) {
		List<Perfil> perfisDescendentes = new ArrayList<Perfil>();
		
		if(perfilUsuario.getPerfilFilho() != null) {
			Collection<Perfil> perfisFilhos = perfilUsuario.getPerfilFilho();
			for(Perfil perfilAtual : perfisFilhos) {
				perfisDescendentes.addAll(recuperarPerfisDescendentes(perfilAtual));
			}
		}
		
		perfisDescendentes.add(perfilUsuario);
		
		return perfisDescendentes;
	}

	/**
	 * realiza a troca de senha do operador
	 */
	@Override
	public boolean trocaSenha(accessControl.Operador operador, String senhaAtual, String novaSenha) throws ControleAcessoException{
		
		UsuarioDAOImpl usrDAO = new UsuarioDAOImpl();
		UsuarioImpl usrRetrieved;
		UsuarioImpl usr = (UsuarioImpl) operador;
		usrRetrieved = (UsuarioImpl) getOperador(usr.getLogin());
		
		if (!usrRetrieved.getSenha().equals(senhaAtual)) return false;
		
		usrRetrieved.setSenha(novaSenha);
		Calendar calendar = new GregorianCalendar();
		calendar.add(Calendar.DATE, PROXIMA_TROCA_SENHA_DIAS);
		usrRetrieved.setDataValidadeSenha(calendar.getTime());
		
		try {
			usrDAO.update(usrRetrieved);
		}
		catch (br.gov.mdarte.controleacesso.cd.DAOException exception) {
			exception.printStackTrace();
			return false;
		}

		return true;
	}	

	/**
	 * Bloqueia o acesso do usuário
	 */
	@Override
	public void bloqueiaUsuario(String usuario) {
		
	}		

	/**
	 * Verifica se o acesso do usuário está bloqueado
	 */
	@Override
	public boolean usuarioBloqueado(String usuario) {
		return false;
	}	

	/**
	 * Verifica se a senha é fraca
	 */
	@Override
	public boolean senhaFraca(String senha) {
		
		/* IMPLEMENTACAO SUGERIDA
		 *
		 * (a senha deve possuir pelo menos 8 caracteres,
		 * incluindo numerais, letras maiúsculas,
		 * letras minúsculas e símbolos)
		 */
		 
		if (senha == null) {
			return true;
		}
		
		if (senha.length() < 8) {
			return true;
		}
		
		String numerais = "0123456789";
		String maiusculas = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		String minusculas = "abcdefghijklmnopqrstuvwxyz";
		String simbolos = " !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";

		boolean achouNumeral = false;
		boolean achouMaiuscula = false;
		boolean achouMinuscula = false;
		boolean achouSimbolo = false;
		
		for (int i = 0; i < senha.length(); i++) {
			achouNumeral |= numerais.indexOf(senha.charAt(i)) > -1;
			achouMaiuscula |= maiusculas.indexOf(senha.charAt(i)) > -1;
			achouMinuscula |= minusculas.indexOf(senha.charAt(i)) > -1;
			achouSimbolo |= simbolos.indexOf(senha.charAt(i)) > -1;
		}
		
		return !achouNumeral || !achouMaiuscula || !achouMinuscula || !achouSimbolo;
		
	}
	
	/**
	 * lista as restricoes em um map onde a chave eh o perfil e o valor a colecao de restricoes do perfil
	 */
	@Override
	public java.util.HashMap<String,java.util.Collection<accessControl.Restricao>> getRestricoes(accessControl.Operador operador, accessControl.Servico servico) throws ControleAcessoException {
		// TODO Auto-generated method stub
		return null;
	}	
	
	/**
	*	Busca os perfis associados ao servico
	*/
	@Override
	public  java.util.Collection<accessControl.Perfil> buscaPerfisServico(accessControl.Servico servico) throws ControleAcessoException{
		
		return null;
	}
	
	public  static class RestricaoDinamicaImpl {
	}	

	public void agendaTarefas() {
	
	}
}